@page "/"
@inject IJSRuntime JSRuntime
@inject HttpClient Http
@inject NavigationManager NavManager
@using ExtensionMethods
@using BrowserInterop.Extensions
@using BrowserInterop.Geolocation
@using BlazorCurrentDevice
@implements IAsyncDisposable

<div id="map"></div>
<div class="modal fade @alertModalClass" tabindex="-1" role="dialog" style="display:@alertModalDisplay; overflow-y: auto;" id="alertModal">
    <div class="d-flex justify-content-center">
        <div class="modal-dialog modal-confirm">
            <div class="modal-content">
                    <div class="modal-header-warning justify-content-center">
                        <img src="Images/alert.png">
                    </div>
                    <div class="modal-body text-center">
                        <h4>Alert!</h4>
                        <h5>It is recommended to enable location on your browser for trail browsing.</h5>
                        <button class="btn btn-success" @onclick="CloseAlert" data-dismiss="modal"><span>Understood</span></button>
                    </div>
            </div>
        </div>
    </div>
</div>

<div class="modal fade @errorModalClass" tabindex="-1" role="dialog" style="display:@errorModalDisplay; overflow-y: auto;" id="errorModal">
    <div class="d-flex justify-content-center">
        <div class="modal-dialog modal-confirm">
            <div class="modal-content">
                <div class="modal-header-error justify-content-center">
                    <img src="Images/alert.png">
                </div>
                <div class="modal-body text-center">
                    <h4>Error!</h4>
                    <h5>Trail walking is supported on mobile devices only!</h5>
                    <button class="btn btn-success" @onclick="CloseError" data-dismiss="modal"><span>Understood</span></button>
                </div>
            </div>
        </div>
    </div>
</div>


@code{

    List<TrailContainer> trails = new List<TrailContainer>();

    private WindowNavigatorGeolocation geolocationWrapper;
    private GeolocationPosition geolocationPosition;

    private List<GeolocationPosition> positionHistory = new List<GeolocationPosition>();

    private IAsyncDisposable geopositionWatcher;

    [Inject] IBlazorCurrentDeviceService BlazorCurrentDeviceService { get; set; }

    private string alertModalDisplay = "none;";
    private string alertModalClass = "hide";
    private string errorModalDisplay = "none;";
    private string errorModalClass = "hide";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var dotNetObjRef = DotNetObjectReference.Create(this);

            var window = await JSRuntime.Window();
            var navigator = await window.Navigator();
            geolocationWrapper = navigator.Geolocation;

            geolocationPosition = (await geolocationWrapper.GetCurrentPosition(new PositionOptions()
            {
                EnableHighAccuracy = true,
                MaximumAgeTimeSpan = TimeSpan.FromHours(1),
                TimeoutTimeSpan = TimeSpan.FromMinutes(1)
            })).Location;

            if (geolocationPosition == null)
            {
                OpenAlert();
                await JSRuntime.InvokeAsync<string>(
            "initializeTrailMap", 0, 0, dotNetObjRef, false);
            }
            else
            {
                await JSRuntime.InvokeAsync<string>(
            "initializeTrailMap", geolocationPosition.Coords.Latitude, geolocationPosition.Coords.Longitude, dotNetObjRef, true);
            }


        }
        base.OnAfterRender(firstRender);
    }

    [JSInvokable]
    public async void StartTrail(int trailID)
    {
        bool mobile = await BlazorCurrentDeviceService.Mobile();
        if (mobile)
        {
            NavManager.NavigateTo("/TrailProgress/" + trailID.ToString());
        }
        else
        {
            OpenError();
        }

    }

    [JSInvokable]
    public async void FindTrails()
    {
        trails = await Http.GetFromJsonAsync<List<TrailContainer>>("sample-data/testTrail.json");

        UpdateMarkers();
    }

    public async void UpdateMarkers()
    {
        foreach (TrailContainer trail in trails)
        {
            await AddMarker(trail);
        }
    }

    [JSInvokable]
    public async void FilterMarkers(int difficulty, int length)
    {
        trails = await Http.GetFromJsonAsync<List<TrailContainer>>("sample-data/testTrail.json");

        await JSRuntime.InvokeAsync<string>(
        "clearMarkers");

        var filterQuery = from trail
                          in trails
                          where trail.Diff <= difficulty && trail.Length <= length
                          select trail;

        List<TrailContainer> filteredTrails = new List<TrailContainer>();

        foreach (var trail in filterQuery)
        {
            filteredTrails.Add(trail);
        }

        trails = filteredTrails;

        UpdateMarkers();
    }

    private async Task AddMarker(TrailContainer trail)
    {
        string difficulty = trail.Diff.ToTrailStars();

        string infoWindowContent = "<div id=content>" +
        "<p style=\"font-size:25px\"> Length: " + trail.Length + "km </p>" +
        "<p style=\"font-size:25px\"> Difficulty: " + difficulty + "</p>" +
        "<button title=\"See trail only\" onclick = \"showTrailOnly()\" ><img src = \"Images/route.png\" ></button>" +
        "<button title=\"Walk the trail\" onclick = \"startTrail(" + trail.ID.ToString() + ")\" ><img src = \"Images/walk.png\" ></button>" +
        "</div>";

        await JSRuntime.InvokeAsync<string>(
            "addMarker", trail.Lat, trail.Lng, infoWindowContent, (int)trail.trailType, trail.GeoJsonData);
    }

    public async ValueTask DisposeAsync()
    {
        if (geopositionWatcher != null)
        {
            await geopositionWatcher.DisposeAsync();
        }

    }


    private async void OpenAlert()
    {
        alertModalDisplay = "block;";
        alertModalClass = "show";
        StateHasChanged();
    }
    private async void CloseAlert()
    {
        alertModalDisplay = "none;";
        alertModalClass = "hide;";
        StateHasChanged();
    }
    private async void OpenError()
    {
        errorModalDisplay = "block;";
        errorModalClass = "show";
        StateHasChanged();
    }
    private async void CloseError()
    {
        errorModalDisplay = "none;";
        errorModalClass = "hide";
        StateHasChanged();
    }

}